[ { "title": "Scalafmt", "url": "/play-tutorial/posts/scalafmt/", "categories": "Formatting", "tags": "scalafmt", "date": "2020-04-07 01:00:38 +0300", "snippet": "Scalafmt formats code so that it looks consistent between people on your team.For example, it can automatically rewrite this code, which has a weird indentation:12345// Example 1: parameters with indentation after the parenthesiscase class Demo(a: String, b: Int, c: Char ..." }, { "title": "SLF4J", "url": "/play-tutorial/posts/slf4j/", "categories": "Logging", "tags": "logging, slf4j", "date": "2020-04-07 01:00:36 +0300", "snippet": "It’s time to add logging to our app.We will add logging using SLF4J, and bind the implementation to logback.SLF4J, Simple Logging Facade for Java, serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, Logback, Log4j) allowing the end user to plug in the ..." }, { "title": "Macwire", "url": "/play-tutorial/posts/macwire/", "categories": "Dependency Injection", "tags": "macwire, compile time dependency injection", "date": "2020-04-07 01:00:34 +0300", "snippet": "How MacWire worksMacWire uses scala macros to instantiate new objects, using values in the enclosing types for constructor parameters.Consider 2 services, X and Y, and three dependencies, A, B and C:12345class Aclass Bclass Cclass X(a: A, b: B)class Y(c: C)Without MacWire, we can instantiate the ..." }, { "title": "Circe", "url": "/play-tutorial/posts/circe/", "categories": "Json", "tags": "circe, json", "date": "2020-04-07 01:00:32 +0300", "snippet": "play-json enabled us to class-up json (deserializing it from string to a case class) and to serialize json with relative ease.Circe (pronounced SUR-see) is yet another JSON library for Scala.It enables automatic derivation of encoders and decoders, generic derivation via discriminators, schema va..." }, { "title": "Play modes", "url": "/play-tutorial/posts/play-modes/", "categories": "Modes", "tags": "modes", "date": "2020-04-07 01:00:30 +0300", "snippet": "Play has 3 modes: Dev, Prod and Test.Whenever a play application is started, it is started using one of the 3 modes above.For example, when running Play with sbt run the mode will be Dev.When running with sbt test the mode will be Test.When running the app after creating a distribution of it (e.g..." }, { "title": "DB evolutions", "url": "/play-tutorial/posts/db-evolutions/", "categories": "Database", "tags": "db evolutions, db api", "date": "2020-04-07 01:00:30 +0300", "snippet": "You can create your schema manually and the app will work.However, each developer that clones the code will have to do so too, and it results in a poor development experience.While we have many repositories that suffer from this problem, we can fix it with little effort by using db evolutions.Add..." }, { "title": "Adding database access", "url": "/play-tutorial/posts/adding-database-access/", "categories": "Database", "tags": "database, db api", "date": "2020-04-07 01:00:28 +0300", "snippet": "We will read the dishes from a DB instead of from a mutable set in memory.Add JDBC and DB driverAdd jdbc support and h2 driver to your project. in build.sbt:12345libraryDependencies ++= Seq( jdbc, &quot;com.h2database&quot; % &quot;h2&quot; % &quot;1.4.197&quot;, // more dependencies here)Relo..." }, { "title": "Moving the logic to a library", "url": "/play-tutorial/posts/moving-the-logic-to-a-library/", "categories": "Library", "tags": "compile time dependency injection, tests", "date": "2020-04-07 01:00:24 +0300", "snippet": "Even though the marshalling and unmarshalling of the request is much simpler now,our logic is still written in the controller.This means that in order to test our logic we need to create an application (a fake one),which is slow and forces us to use Play’s API in our tests,which in turn may hinde..." }, { "title": "Adding Logic", "url": "/play-tutorial/posts/adding-logic/", "categories": "Controller", "tags": "controller, action, json", "date": "2020-04-07 01:00:22 +0300", "snippet": "We will add some logic and refactor in the next sections.We will build a dish menu for our users.Defining RoutesFirst, let’s add three new routes to the conf/routes file:123GET /dishes com.example.playground.dish.DishController.allDishesGET /dishes/:name com.example.playgr..." }, { "title": "Compile-Time Dependency Injection", "url": "/play-tutorial/posts/compile-time-dependency-injection/", "categories": "Dependency Injection", "tags": "compile time dependency injection", "date": "2020-04-07 01:00:20 +0300", "snippet": "When you add a dependency to a controller (directly or indirectly) or when you refactor a class - if you forget to wire a dependency in your module, you will encounter this error at runtime.We would like to tackle this problem.The main advantage of runtime dependency injection is that it is simpl..." }, { "title": "Class-up Your Config", "url": "/play-tutorial/posts/class-up-your-config/", "categories": "Config", "tags": "typesafe config, pureconfig", "date": "2020-04-07 01:00:18 +0300", "snippet": "In the previous example there was some repetition.Parsing the config to a person was a bit complex, as well as creating a Path instance, UUID instance and so on.A bigger problem is that it is not straightforward to write a system test that ensures that the config keys are read properly in the cod..." }, { "title": "Working With Config", "url": "/play-tutorial/posts/working-with-config/", "categories": "Config", "tags": "typesafe config", "date": "2020-04-07 01:00:16 +0300", "snippet": "We will first start by adding demo config to our app and reading it manually.Add the following to your conf/application.conf (not inside, but rather under play’s blob):12345678910111213141516name: hotels_best_disheshost: &quot;https://example.com&quot;port: 80hotels: [ &quot;Club Hotel Lutraky G..." }, { "title": "Dockerize the app", "url": "/play-tutorial/posts/dockerize-the-app/", "categories": "Docker", "tags": "docker, sbt native packager", "date": "2020-04-07 01:00:12 +0300", "snippet": "Instead of creating a binary package as our artifact, we will create a docker image.Docker use operating-system-level virtualization to deliver software in packages called containers.You can run many containers for the same image, just like you can run many processes of the same application (e.g ..." }, { "title": "Create a package", "url": "/play-tutorial/posts/create-a-package/", "categories": "sbt dist", "tags": "package, dist, application secret", "date": "2020-04-07 01:00:10 +0300", "snippet": "Create a packageLet’s create a binary version of our application.Open the sbt shell and type dist.This task will create a new zip in your project directory under target/universal/ directory.The package name will be composed of the project name and version as set in build.sbt.You can view it in yo..." }, { "title": "Open the project in IntelliJ", "url": "/play-tutorial/posts/open-the-project-in-intellij/", "categories": "IntelliJ", "tags": "intellij", "date": "2020-04-07 01:00:08 +0300", "snippet": "Open the projectIn IntelliJ, click File -&amp;gt; Open, navigate to the project directory (playground) and click open. TIP:tick v under: Library sources sbt sources use sbt shell for imports use sbt shell for builds It is especially important to use sbt shell for builds, so your..." }, { "title": "Creating a git repository", "url": "/play-tutorial/posts/creating-a-git-repository/", "categories": "git", "tags": "git, github", "date": "2020-04-07 01:00:06 +0300", "snippet": "We will create a git repository to host our code.Prepare .gitignore fileWe will create a .gitignore file that contains files that should not be tracked.gitignore.io creates a .gitignore file according to the technologies used in the project.Open gitignore.io in your browser, add the terms intelli..." }, { "title": "Creating a skeleton project", "url": "/play-tutorial/posts/creating-a-skeleton-project/", "categories": "Giter8", "tags": "giter8, skeleton", "date": "2020-04-07 01:00:04 +0300", "snippet": "Generate a skeleton with giter8In terminal, in your repos directory, create a new project using a giter8 template for play-scala-seed:12cd ~/repossbt new playframework/play-scala-seed.g8You will be asked for more information.Fill out the following: Field Value nam..." }, { "title": "Prerequisites", "url": "/play-tutorial/posts/prerequisites/", "categories": "Prerequisites", "tags": "prerequisites, mac", "date": "2020-04-07 01:00:02 +0300", "snippet": " Download and install JDK 8+ from AdoptOpenJDK’s website. Use HotSpot JVM (default). Download and install Docker. Download and install SBT and Scala, e.g using Homebrew or SDKMAN: 123456# update brewbrew update# install sbt if missingbrew list sbt || brew install sbt# optional..." }, { "title": "About", "url": "/play-tutorial/posts/about/", "categories": "", "tags": "", "date": "2020-04-07 01:00:02 +0300", "snippet": "In this tutorial we will create a new Play Framework application from scratch and play around with its build.We will see how to work with config, use compile-time dependency injection,how to dockerize the app, work with json, access the DB, construct the logic so we willhave easier time to update..." } ]
